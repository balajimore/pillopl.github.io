---
layout: post
title: Stub & Verify?
comments: true
---

<p style="text-align:justify;">
Several times lately I came across Spock tests, which conceptually looked as follows:
</p>

```groovy
    static final BigDecimal ANY_AMOUNT = new BigDecimal("100.00")
    
    Payment payment = aSamplePayment()
    Client client = aSampleClient()
    
    PaymentCreator paymentCreator = Mock(PaymentCreator)
    PaymentRepository repository = Mock(PaymentRepository)

    @Subject
    Payments payments = new Payments(paymentCreator, repository)

    def "should create outgoing payment for loan"() {
        when:
            Payment actualPayment = payments.saveOutgoingFor(client, ANY_AMOUNT)
        then:
            1 * paymentCreator.createOutgoing(client, ANY_AMOUNT) >> payment
            1 * repository.save(payment)
            actualPayment == payment
    }
```  

<p style="text-align:justify;">
Spock allows you to stub and verify collaborator at once.<a href="https://spockframework.github.io/spock/docs/1.0/interaction_based_testing.html"> See section 'Combining Mocking and Stubbing'</a>. It is followed by sections which describe couple of discouraged solutions to testing, like partial stubs or stubbing static methods. In my opinion above section should also have this sidenote:
</p>

<blockquote class="cite">
      <p>(Think twice before using this feature. It might be better to change the design of the code under specification.)</p>
</blockquote>

***Design smell!***

Consider following implementation under test:

```java
 Payment saveOutgoingFor(Client client, BigDecimal amount) {
        Payment payment = paymentCreator.createOutgoing(client, amount);
        paymentRepository.save(payment);
        return payment;
    }
```

What it does is creating new payment and saving it in some kind of storage. Actually, the paymentRepository.save() method could return stored payment, so that we could get rid of last line. Such design can be explained like the following "to something with the payment, return it, do something else, and return it". Two actions are being done by two collaborating services. Actually we can cut it to "do something andThen do something else". Rings a bell? It is just function composition and you can read why dependency injection in most cases is just function composition <a href="http://www.nurkiewicz.com/2015/08/dependency-injection-syntax-sugar-over.html">here</a>. What we care about is the result of function composition, which is being done inside one method. We don't care about partial steps and about their implementation. We are interested in the result, <b>state</b>.

1. CQS, test isolation, mockistt TDD, fowlers implementation leaks, behaviour vs state, DI syntatic sugar


